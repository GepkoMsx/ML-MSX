using png2msxSc5;
using System.Drawing;
using System.Runtime.Versioning;

internal class Program
{
    private readonly static Dictionary<string, byte> _colorMap =[];
    private static void Help()
    {
        Console.WriteLine("png2msxSc5");
        Console.WriteLine("Converting a png image of 256x192 pixels or less into an msx screen 5 file.");
        Console.WriteLine("byte info: CCCCcccc C = color code even bit, c = color code odd bit");
        Console.WriteLine("PNG file should have 16 colors max!");
        Console.WriteLine("Arguments:");
        Console.WriteLine("PNGpath: Mandatory path to png file");
        Console.WriteLine("-txt: make .as include data file instead");
        Console.WriteLine("-cmap filename: force a colormap to be used.");
        Console.WriteLine("");
        Console.WriteLine("Layout colormap: as the -txt generated it. (16 lines of db statements with 2 bytes each)");
        Console.WriteLine("Example (16 time):    db $77, $77 ; .....");
        Environment.Exit(1);
    }

    private static void Banner()
    {
        Console.WriteLine("png2msxSc5 - Convert PNG to MSX Screen 5 format");
        Console.WriteLine("-----------------------------------------------");
    }

    [SupportedOSPlatform("windows")]
    private static void Main(string[] args)
    {
        Banner();

        if (args.Length < 1 || args.Length > 4)
        {
            Help();
        }

        // Parse arguments.
        var infile = args[0];
        var txt = false;

        for (int i = 1; i < args.Length; i++)
        {
            if (args[i] == "-txt")
            {
                txt = true;
            }
            else if (args[i] == "-cmap")
            {
                if (i + 1 >= args.Length)
                {
                    Console.WriteLine("Error: -cmap option requires a filename argument!");
                    Environment.Exit(1);
                }
                var cmapFile = args[i + 1];
                ReadColorMap(cmapFile);
                i++; // skip next argument since it's the filename
            }
            else
            {
                Console.WriteLine($"Unknown argument: {args[i]}");
                Help();
            }
        }

        Console.WriteLine("Generating " + (txt ? "text file" : "binary file") + " from " + infile);

        var image = (Bitmap)Image.FromFile(infile, true);
        if (image.Width > 256 || image.Height > 212)
        {
            Help();
        }

        // initialize
        var outfile = Path.ChangeExtension(infile, (txt) ? "as5" : "bi5");
        File.Delete(outfile);
        var handle = File.OpenWrite(outfile);

        if (txt)
        {
            handle.WriteLine("; Generated by png2msxSc5 from " + infile);
            handle.WriteLine("PixelData:");
        }

        var color = GetColorByte(image.GetPixel(0, 0), image.GetPixel(1, 0));
        WriteHMMCheader(handle, image.Width, image.Height, txt, color);

        if (txt) 
        { 
            handle.WriteLine("    ; Pixel data (color codes)");
        }
        for (int y = 0; y < image.Height; y++)
        {
            if (txt)
            {
                handle.Write("    db ");
            }
            for (int x = 0; x < image.Width; x+=2)
            {
                color = GetColorByte(image.GetPixel(x, y), image.GetPixel(x+1, y));
                if (txt)
                {
                    handle.Write($"${color:X2}");
                    if (x < image.Width - 2)
                    {
                        handle.Write(", ");
                    }
                }
                else
                {
                    handle.WriteByte(color);
                }
            }

            if (txt)
            {
                handle.WriteLine();
            }
        }

        // add colors:
        WriteColorMap(handle, txt);

        handle.Close();
    }

    private static byte GetColorByte(Color c, Color d)
    {
        var color1 = ConvertColor(c);
        var color2 = ConvertColor(d);

        return (byte)((color1 << 4) | color2);
    }
    private static byte ConvertColor(Color c)
    {
        var r = (byte)(c.R / 32);
        var g = (byte)(c.G / 32);
        var b = (byte)(c.B / 32);
        var rgbKey = $"R{r}G{g}B{b}";

        if (!_colorMap.TryGetValue(rgbKey, out byte value))
        {
            var colorCode = _colorMap.Count;
            if (colorCode >= 16)
            {
                //Console.WriteLine("Error: More than 16 colors used in image!");
                //Environment.Exit(1);

                // lets find nearest color in _colorMap and return that instead.
                // calculate distance between colors using euclidean distance in rgb space, and return the color code of the closest color.
                double minDistance = double.MaxValue;
                byte closestColorCode = 0;
                foreach (var kvp in _colorMap)
                {
                    var existingR = Convert.ToByte(kvp.Key.Substring(1, 1));
                    var existingG = Convert.ToByte(kvp.Key.Substring(3, 1));
                    var existingB = Convert.ToByte(kvp.Key.Substring(5, 1));
                    var distance = Math.Sqrt(Math.Pow(r - existingR, 2) + Math.Pow(g - existingG, 2) + Math.Pow(b - existingB, 2));
                    if (distance < minDistance)
                    {
                        minDistance = distance;
                        closestColorCode = kvp.Value;
                    }
                }
                return closestColorCode;

            }

            value = (byte)colorCode;
            _colorMap[rgbKey] = value;
        }

        return value;
    }
    private static void WriteColorMap(FileStream handle, bool txt)
    {
        if (txt)
        {
            handle.WriteLine("PaletteData:");
            handle.WriteLine("    ; PaletteData: R G B(0 - 7)");
        }

        for (int i = 0; i < _colorMap.Count; i++)
        {
            var name = _colorMap.ElementAt(i).Key;
            var r = name.Substring(1, 1);
            var g = name.Substring(3, 1);
            var b = name.Substring(5, 1);
            var byte1 = (byte)((Convert.ToByte(r) << 4) | Convert.ToByte(b));
            var byte2 = Convert.ToByte(g);

            if (txt)
            {
                handle.WriteLine($"    db ${byte1:X2}, ${byte2:X2} ; Color {i}");
            } 
            else
            {
                handle.Write([byte1, byte2]);
            }
        }

        for (int j = _colorMap.Count; j < 16 ; j++)
        {
            var nul = (byte)0;

            if (txt)
            {
                handle.WriteLine($"    db ${nul:X2}, ${nul:X2} ; UnusedColor {j}");
            }
            else
            {
                handle.Write([nul, nul]);
            }
        }
    }
    private static void ReadColorMap(string file)
    {
        // skip all lines that dont hav e "db ", then check if we have 16 lines with 2 bytes each, and populate _colorMap accordingly.
        var lines = File.ReadAllLines(file);
        var list = lines.Where(l => l.Contains("db "));
        if (list.Count() != 16)
        {
            Console.WriteLine("Error: Color map file should have exactly 16 lines with 'db ' statements!");
            Environment.Exit(1);
        }

        for (int i = 0; i < 16; i++)
        {
            var line = list.ElementAt(i);
            var noComments = line.Split(';')[0]; // remove comments
            var parts = noComments.Split(["db ", ","], StringSplitOptions.TrimEntries | StringSplitOptions.RemoveEmptyEntries);
            if (parts.Length != 2)
            {
                Console.WriteLine("Error: Each line in color map file should have exactly 2 bytes!");
                Environment.Exit(1);
            }
            var byte1 = Convert.ToByte(parts[0].Trim().TrimStart('$'), 16);
            var byte2 = Convert.ToByte(parts[1].Trim().TrimStart('$'), 16);
            var r = (byte)((byte1 >> 4) & 0x07);
            var b = (byte)(byte1 & 0x07);
            var g = (byte)(byte2 & 0x07);
            var rgbKey = $"R{r}G{g}B{b}";
            _colorMap[rgbKey] = (byte)i;
        }
    }

    private static void WriteHMMCheader(FileStream handle, int width, int height, bool txt, byte first2colors)
    {
        if (txt)
        {
            /*
                - 4 bytes Begin position, usually overwritten by the program (DX, DY)
                - 2 bytes Image width in pixels  (always even nr of pixels!)
                - 2 bytes Image height in pixels
                - 1 byte  1st 2 pixels. 
                - 1 byte  The ARG component, usually $00
                - 1 byte  The HMMC command, always $F0
            */
            handle.WriteLine("    ; HMMC header");
            handle.Write("    db $00, $00, $00, $00, ");
            handle.Write($"${width:X2}, $00, ");           // width and height never bigger than 256, so we can just write the low byte here.
            handle.Write($"${height:X2}, $00, ");
            handle.WriteLine($"${first2colors:X2}, $00, $F0");
        } 
        else
        {
            handle.Write([0,0,0,0]);                            // dx dy
            handle.Write([(byte)width, 0, (byte)height, 0]);    // nx, ny
            handle.Write([first2colors, 0, 0xF0]);              // col, arg, cmd
        }
    }
}