;; ==[ CALL MemSwapPage1 ]===============================================
;; Swapt Page1 van BASIC ROM, naar RAM
;;
;; INPUT:
;; - MEMNRBANKS (1) : Bevat het aantal memoryslots (max 32 = 512kb)
;; - MEMPAGE3   (1) : Bevat de memory page dat voor page 3 gerbuikt wordt. (Deze niet veranderen!)
;;
;; Werking:
;; page 2 & 3 hebben memory
;; zet dat slot ook op page 1.
;; 
;; Heeft ook memory fix voor memmapcheck. Probeert door te nummeren met de segmenten vanaf page3.
;; Dus page 3 heeft segment 0, dan page 2 segment 1, page 1 segment 2.

;; pages (what sees the Z80) and slots (where is the memory)
;; Poort $A8 (Primary Slot)
;; Het register op poort $A8 is als volgt ingedeeld (2 bits per page):
;; -Bits 0-1: Slot voor Page 0 ($0000-$3FFF)
;; -Bits 2-3: Slot voor Page 1 ($4000-$7FFF)
;; -Bits 4-5: Slot voor Page 2 ($8000-$BFFF)
;; -Bits 6-7: Slot voor Page 3 ($C000-$FFFF)


MemSwapPage1:
    in a, ($a8)
    ld b, a             ; Isoleer de bits van Page 2 en schuif ze naar de positie van Page 1
    
    and %00110000       ; Houd alleen bits 4-5 over (Page 2)
    rrca                ; Verschuif 2 bits naar rechts
    rrca                ; nu staan ze op positie 2-3
    ld c, a             ; Bewaar dit "masker" in C

    rrca                ; tussentijds expanded slot check doen (bewaar BC voor later!)
    rrca                ; A bevat nu het Primary Slot nummer (0, 1, 2 of 3)
    ld d, a             ; bewaar slotnummer in D
    ld hl, $FCC1        ; EXPTBL (vlaggen voor expanded slots)
    add a, l
    ld l, a
    ld a, (hl)          ; Lees vlag voor dit slot
    and $80             ; Test bit 7 (1 = expanded)
    jr z, NoSubslot     ; Als niet expanded, zijn we klaar

                        ; Lees het Subslot-register ($FFFF) van dit slot
                        ; Om $FFFF te kunnen lezen, moet het betreffende slot in Page 3 staan!
    ld a, b             ; Pak originele poort $A8 waarde
    and %00111111       ; Wis Page 3 (bits 6-7)
    ld e, d             ; Pak slot nummer van Page 2
    rl e
    rl e
    rl e
    rl e
    rl e
    rl e                ; Schuif slot naar positie 6-7
    or e                ; Zet dit slot ook in Page 3
    di                  ; Interrupts uit (veiligheid bij wisselen page 3)
    out ($a8), a        ; Nu "kijkt" Page 3 naar hetzelfde slot als Page 2

    ld a, ($ffff)       ; LEES het subslot register
    cpl                 ; MSX hardware bit-invert: subslot register is vaak geinverteerd
    ld e, a             ; Bewaar waarde in E

                        ; Kopieer subslot bits van Page 2 naar Page 1
                        ; Subslot register indeling is gelijk aan $A8: Page 1 = bits 2-3, Page 2 = bits 4-5
    and %00110000       ; Isoleer subslot bits Page 2
    rrca
    rrca                ; Schuif naar positie Page 1
    ld h, a
    ld a, e
    and %11110011       ; Wis oude Page 1 subslot bits
    or h                ; Zet nieuwe bits erin
                        ; Niet inverteren voor schrijven (doet msx zelf)
    ld ($ffff), a       ; SCHRIJF terug naar subslot register    

NoSubslot:              ; nu verder met BC en slotselectie.. (en zetten we Page3 ook weer terug)
    ld a, b             ; Maak Page 1 in de originele waarde leeg en voeg de nieuwe bits toe
    and %11110011       ; Wis de huidige bits van Page 1 (bits 2-3)
    or c                ; Voeg de bits toe die we uit Page 2 hebben gehaald
    
    out ($a8), a        ; Update Slot Register, Schrijf terug naar de hardware
    ld ($fcc1), a       ; Update BIOS mirror (veiligheid)
    ei


;; FOR NOW FIX PAGE 2 LIKE THIS.
    ld a, (MEMNRBANKS)  
    ld b,a
    ld a, (MEMPAGE3)    ; what membank is in page3?
    inc a               ; load next membank in page2.
    cp b                
    jp nz, Main_next    ; too high!, back to 0
    ld a, 0               

Main_next:
    out ($FE), a        ; load page 2.

    inc a
    cp b                
    jp nz, Main_next2    ; too high!, back to 0
    ld a, 0               
Main_next2:
    out ($FD), a        ; load page 2.
    
;; END FOR NOW
    ret