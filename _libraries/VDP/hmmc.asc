;; ==[ CALL HMMC ]===============================================
;; toont een plaatje uit geheugen op scherm
;;
;; INPUT
;; - HL : Adres van pixeldata (begin van HMMC header)
;;
;; GEBRUIKT
;; - Multiply.asc
;; - VDPC, VDPR variabelen.
;;
;; INFO
;; Pixeldata kan gegenereerd worden met de tool png2msxSc5.exe
;; de header, in memory bevat ook de DX, DY coordinaten waar het neergezet wordt.


HMMC:
;; Stuur de 11 parameters naar R36 t/m R46 
;; - R36-37: DX (Low, High)
;; - R38-39: DY (Low, High)
;; - R40-41: NX (Low, High)
;; - R42-43: NY (Low, High)
;; - R44: Kleur / Data
;; - R45: Argument
;; - R46: Commando (zoals #F0 voor HMMC)
    push HL
    ld bc, 4
    add HL, bc
    ld C, (HL)          ; width
    inc HL
    ld B, (HL)          ; width
    inc HL
    ld E, (HL)          ; height
    inc HL
    ld D, (HL)          ; height
    call Multiply       ; HL = BC x DE

    srl h               ; hl = hl/2, dus nu pixels is nu aantal bytes
    rr l
    ex de, hl           ; DE heeft nu het aantal pixelbytes
    pop HL              ; HL heeft nu het adres van pixelData
    
;; TODO: missschien pixelbytes los (extra) opslaan ipv uitrekenen?

    DI                  
    in a, (VDPC)        ; even status check om vdp te schonen

    ld a, 36            ; auto-increment (geen $80) vanaf register 36
    out (VDPC), a
    ld a, $80 + 17      ; schrijf ($80) naar R17
    out (VDPC), a    
    
    ld b, 11
    ld c, VDPR  

HMMCHeaderLoop:
    outi                ; ; - out (c), (hl) - inc hl - dec b
    jr nz, HMMCHeaderLoop

; wacht op vdp?

; Stuur de eigenlijke pixeldata
    ld a, $80+44        ; geen increment ($80) naar register 44
    out (VDPC), a
    ld a, $80+17        ; schrijf naar R17
    out (VDPC), a
    
    dec de              ; remaining bytes to send
    inc HL              ; skip 1st pixel
    ld c, VDPR

HMMCPixelLoop:
    ld a, (HL)
    out (c), a        ; VDP zet deze pixel op de volgende positie
    inc HL
    dec de
    ld a, d
    or e
    jp nz, HMMCPixelLoop
    ei

    ret 