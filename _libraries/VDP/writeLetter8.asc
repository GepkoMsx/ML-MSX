;; ==[ CALL WriteLetter8 ]===============================================
;;
;; Writes a letter with font on screen 8
;;
;; uses:
;; - const    LOCHAR		
;; - const    FONT_HEIGHT	
;; - label    FontData:
;; - library  Multiply
;;
;; The fontdata consists of <FONT_HEIGHT> bytes per letter, 1 bit per pixel.
;; starting with ascii LOCHAR. 
;; See: https://8bitworkshop.com/bitmapfontgenerator/
;; settings: mirror on, flip on, w:8, h:12,y-off:4, output: ASS Zmac, font: ctrld/fixed/bold/R/13/7/C, 
;;           chars: ascii upper and lower
;;
;; Omdat je in Screen 8 werkt (1 pixel = 1 byte), moet je elk bitje uit je bitmap 
;; "opblazen" naar een volledige byte in het VRAM. Een 1 in je bitmap wordt de 
;; voorgrondkleur (bijv. #FF voor wit), een 0 wordt de achtergrondkleur 
;; (bijv. #00 voor transparant/zwart).
;;
;; De meest efficiÃ«nte manier om dit te doen is met het VDP-commando LMMC 
;; (Logical Move Memory to VRAM).
;; Het Plan:
;; 1.	Stel de VDP in voor een LMMC naar de gewenste X,Y positie met een breedte van 8 en hoogte van 8.
;; 2.	Lees een byte uit je RAM-bitmap (dit zijn 8 pixels horizontaal).
;; 3.	Vouw dit byte bit-voor-bit uit en stuur voor elk bit een byte naar de VDP datapoort (#9B).
;;
;; INPUT: 
;; - A - Letter ASCII waarde
;; - B - Kleur van de letters
;; - DE - locatie (D=x, E=y)
;;
;; LMMC heeft zelfde header structuur als de VMMC. 
;; We doen het nu met de hand, want, letter voor letter. 
WriteLetter8:
    push DE
    push BC

    sub LOCHAR          ; a start op 0-1-2-3, moet worden 0-12-24-36
    ld c, a
    ld b, 0
    ld de, FONT_HEIGHT
    call Multiply       ; HL = DE * BC
    ld de, FontData
    add hl, de          ; HL is nu het adres van 1e byte van letter
    
    pop bc              ; b = kleur
    pop de              ; de = locatie HL = locatie van letter

    ld a, (HL)          ; bepaal kleur van 1e bit
    rlca                ; Schuif bit 7 naar de Carry flag
    sbc a, a            ; Als Carry=1 dan A=#FF, als Carry=0 dan A=#00
    and b               ; A = (#FF AND B) wordt B, of (#00 AND B) wordt 0
    push af             ; a pushed = de kleur (0, of b)
;LMMC header
    DI                  
    in a, (VDPC)        ; even status check om vdp te schonen

    ld a, 36            ; auto-increment (geen $80) vanaf register 36
    out (VDPC), a
    ld a, $80 + 17      ; schrijf ($80) naar R17
    out (VDPC), a    
    
    ld c, VDPR          
    ld a, 0
    out (c), d          ; DX low
    out (c), a          ; DX high = 0
    out (c), e          ; DY low
    out (c), a          ; DY high = 0  ---> dus VRAM page 0
    ld d, 8
    out (c), d          ; NX low = 8 pixels
    out (c), a          ; NX high = 0
    ld e, FONT_HEIGHT   
    out (c), e          ; NY low
    out (c), a          ; NY heigh
    pop af
    out (c), a          ; kleur 1e bit.
    ld a, %00001000     ; ARG (Logische operatie: TIMP / Transparant)
    out (c), a
    ld a, $B0           ; LMMC
    out (c), a

; setup VDP voor de eigenlijke pixeldata
    ld a, $80+44        ; geen increment ($80) naar register 44
    out (VDPC), a
    ld a, $80+17        ; schrijf naar R17
    out (VDPC), a

;pixeldata:             

    ld d, b             ; D = kleur, E = FONT_HEIGHT, HL -> addr letter
                        ; 1e pixel is al gedaan

    ld b, e             ; font_height keer
RowLoop:
    ld c, (HL)          ; c = de bits
    ld e, 8             ; 8 bits loop
BitLoop:
    rl c                ; hoogste bit naar carry
    sbc a,a             ; a = 0 of ff
    and d               ; a = 0 of kleur
    out (VDPR), a

    dec e;
    jr nz, BitLoop

    inc hl
    djnz RowLoop
    EI
    ret 